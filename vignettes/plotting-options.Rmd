---
title: "Plotting options"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    theme: united
    toc_float: true
vignette: >
  %\VignetteIndexEntry{plotting-options}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Quick links

 - [Index](index.html)
 - [Getting started](getting-started.html)
 - [Colour palette](rba-colours.html)
 - [Package documentation (pdf)](https://angusmoore.github.io/arphit/arphit.pdf)
 - [qplot options](qplot-options.html)

# Introduction

This vignette details all the plotting options available in `arphit`. If you are learning how to use `arphit`, you should read the [getting started guide](getting-started.html) first.

```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
library(arphit)
```
# Data types

## tibbles and data.frames

```{r}
simple_data <- data.frame(date = seq.Date(from = as.Date("2000-03-01"),
                                          length.out = 10,
                                          by = "quarter"),
                          y1 = rnorm(10),
                          y2 = rnorm(10),
                          y3 = rnorm(10),
                          y4 = rnorm(10))
long_data <- data.frame(date = rep(seq.Date(from = as.Date("2000-03-01"),
                                            length.out = 10,
                                            by = "quarter"), 2),
                        y1 = rnorm(20),
                        y2 = rnorm(20),
                        group_var = c(rep("A", 10), rep("B", 10)))
scatter_data <- data.frame(x = rnorm(10), y = rnorm(10))
```

## ts

Here we create a time series starting in 2000Q1 (`frequency = 4` means quarterly) with 10 random observations for two variables: `x1` and `x2`.
```{r}
ts_data <- ts(data.frame(x1 = rnorm(10), x2 = rnorm(10)), frequency = 4, start = c(2000, 1))
```

# Layouts and panels

There are nine supported layouts, with up to 8 panels. *Right hand side axes count as separate panels in some layouts.* Panels are numbered from left to right, top to bottom.

  1. One-panel "1". This is the default if you do not supply a value for `layout`. Despite its name this layout has *two* panels. Panel "1" corresponds to the left axis; panel "2" corresponds to the right axis.
```{r, eval = FALSE}
arphitgg(layout = "1")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
library(arphit)
agg_draw(arphitgg(layout = "1"), filename = "layout_1.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_1.png")
```  

  2. Two-panel vertical "2v". This layout has two panels, divided vertically. Panel "1" is the left panel, panel "2" the right.
```{r, eval = FALSE}
arphitgg(layout = "2v")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(arphitgg(layout = "2v"), filename = "layout_2v.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_2v.png")
```  

  3. Two-panel horizontal "2h". This layout has *four* panels. Panels "1" and "2" are the left and
right axes of the top panel. "3" and "4" for the bottom.
```{r, eval = FALSE}
arphitgg(layout = "2h")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(arphitgg(layout = "2h"), filename = "layout_2h.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_2h.png")
```  
  
  4. Two-by-two "2b2". This layout is very similar to "2h", except the left and right panels are divided, rather than axes.
```{r, eval = FALSE}
arphitgg(layout = "2b2")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(arphitgg(layout = "2b2"), filename = "layout_2b2.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_2b2.png")
```  

  5. Three panel vertical "3v":
```{r, eval = FALSE}
arphitgg(layout = "3v")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(arphitgg(layout = "3v"), filename = "layout_3v.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_3v.png")
```  
  6. Three panel horizontal "3h" (has left and right axes, like "2h"):
```{r, eval = FALSE}
arphitgg(layout = "3h")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(arphitgg(layout = "3h"), filename = "layout_3h.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_3h.png")
```  

  7. Six panel three-by-two "3b2":
```{r, eval = FALSE}
arphitgg(layout = "3b2")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(arphitgg(layout = "3b2"), filename = "layout_3b2.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_3b2.png")
```  

  8. Four panel horizontal "4h" (has left and right axes like "2h"):
```{r, eval = FALSE}
arphitgg(layout = "4h")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(arphitgg(layout = "4h"), filename = "layout_4h.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_4h.png")
```  

  9. Eight panel four-by-two "4b2":
```{r, eval = FALSE}
arphitgg(layout = "4b2")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(arphitgg(layout = "4b2"), filename = "layout_4b2.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_4b2.png")
```  

## Portrait-size graphs

If you want a larger, portrait size layout, simply pass in `portait = TRUE`. This works with any of the layouts.
```{r, results = "hide"}
p <- arphitgg(portrait = TRUE)
```
```{r, echo = FALSE, results = "hide"}
agg_draw(p, filename = "layout_portrait.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layout_portrait.png")
```

## (Advanced) Custom graph sizes

You can also manually specify the plot size if you want greater control. This size is for the *whole* graph - i.e. the size of the graph, not the size of a panel. Units are inches (the graphs have been scaled to half original size when included in this document).
```{r, results = "hide"}
p <- arphitgg(plotsize = c(2,10))
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "plotsize.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("plotsize.png")
```

# Layers and aesthetics

## Aesthetic

An aesthetic is the definition of a layer. It tells arphit you to display the data.

### `x` and `y`

The `x` and `y` variables speak for themselves, and must be values in the data you supply. (`x` values can be categorical).
```{r, results = "hide"}
p <- arphitgg() + 
  agg_line(data = simple_data, aes = agg_aes(x = date, y = y1))
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "no-group-aes.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("no-group-aes.png")
```

If your data are a `ts`, the `x` aesthetic does not need to specified, it is automatically the dates in the time series.

### Inheriting aesthetics

Aesthetics inherit from their parent. That is, if you omit part of an aesthetic in the definition of a layer, it will inherit from the parent (if it exists). If you specify both a parent aesthetic and a layer aesthetic, the layer aesthetic overrides.

In this example, the whole aesthetic is inherited:
```{r, results = "hide"}
p <- arphitgg(data = simple_data, aes = agg_aes(x = date, y = y1)) + 
  agg_line()
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "inherit-aes-all.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("inherit-aes-all.png")
```

In this example, we specify the`x` aesthetic in the parent, but specify the y aesthetic in the layer. This is helpful if, for instance, you have many `y` variables you want to plot that all have the same `x` variable.
```{r, results = "hide"}
p <- arphitgg(data = simple_data, aes = agg_aes(x = date)) + 
  agg_line(aes = agg_aes(y = y1))
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "inherit-aes-some.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("inherit-aes-some.png")
```

### Groups

An aesthetic can also specify a `group` variable. This is used when your data is in long form and you have multiple observations on each `x` observation, corresponding to different variables. For instance, `x` might be the date column, `y` the column containing observations of the unemployment rate and `group` the column containing state identifiers.
```{r, results = "hide"}
p <- arphitgg() +
  agg_line(data = long_data, aes = agg_aes(x = date, y = y1, group = group_var))
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "group-aes.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("group-aes.png")
```

### Facets

An aesthetic can also specify a `facet` variable. `facet`s work like `group`s, except that facets are split across panels (and so layers ignore if you give them a panel).
```{r, results = "hide"}
p <- arphitgg() +
  agg_line(data = long_data, aes = agg_aes(x = date, y = y1, facet = group_var))
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "facet.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("facet.png")
```

Data can have both `group`s and `facet`s.
```{r, results = "hide"}
facet_data <- data.frame(x = rep(c(1,2),4),
                         y = rnorm(8),
                         age = c(rep("A", 4), rep("B", 4)),
                         sex = rep(c("F","F","M","M"), 2))
p <- arphitgg() +
  agg_line(data = facet_data, aes = agg_aes(x = x, y = y, group = sex, facet = age))
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "facet-group.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("facet-group.png")
```

### (Advanced) Order of categorical graphs

By default, categorical graphs are ordered by their x-ticks if they have groups 
(e.g. alphabetically) or will use the order in the data if there is not a group
aesthetic.

You can instead specify a variable to order the graph by using the `order` 
part of the aesthetic.

Ordering a bar chart by value:
```{r, results = "hide"}
order_data <- data.frame(x=letters[1:10],
                         y=rnorm(10))
p <- arphitgg(order_data, agg_aes(x=x,y=y,order=y))
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "aes-order-value.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("aes-order-value.png")
```

If you have groups and want to order by value, you need to specify which _group's_ 
value you want to use as the order:
```{r, results = "hide"}
order_data <- data.frame(x=letters[1:10],
                         y=rnorm(10),
                         group = c(rep("A",5),rep("B",5)))
p <- arphitgg(order_data, agg_aes(x=x,y=y,group=group,order=A))
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "aes-order-value-group.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("aes-order-value-group.png")
```

A third alternative way is to use another variable to define the order. In this
example we take data and order it by a variable `order` that is the reverse
of the x variable.
```{r, results = "hide"}
order_data <- data.frame(x = rep(letters[1:10], 2),
            y = rep(1:10, 2),
            group = c(rep("A", 10), rep("B", 10)),
            order = rep(letters[10:1], 2),
            stringsAsFactors = FALSE)
p <- arphitgg(order_data, agg_aes(x=x,y=y,group=group,order=order)) + 
  agg_col(stacked = FALSE)
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "aes-order.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("aes-order.png")
```

## Layers

A layer is a series (or group of series) built from the same aesthetic. In `arphit`, layers must be assigned to a panel. You can have more than one layer per panel.

All require have four common arguments, and some layers have extra options to define their look:
  1. Data
  2. Aesthetic
  3. Panel (defaults to "1" if not supplied)
  4. Colour (optional)

*NB:* Layers will inherit data and aesthetic from their parent if omitted. This is helpful if you want to define multiple layers from the one dataset. (Example below)

There are three types of layers, `agg_line`, `agg_point` and `agg_col`. These are used nearly identically to produce line, scatter and column graphs respectively:
```{r, results = "hide"}
p <- arphitgg(layout = "2h") + 
  agg_line(data = long_data, aes = agg_aes(x = date, y = y1, group = group_var), panel = "1") + 
  agg_col(data = long_data, aes = agg_aes(x = date, y = y2, group = group_var), panel = "3")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "layers.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("layers.png")
```

```{r, results = "hide"}
p <- arphitgg(layout = "1") + 
  agg_point(data = data.frame(x = rnorm(10), y = rnorm(10)), aes = agg_aes(x = x, y = y), panel = "1")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "scatter.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("scatter.png")
```

Layers will inherit data and aesthetic (or parts of the aesthetic) if these are left null in the layer specification. This is handy to save you from having to repeat yourself:
```{r, results = "hide"}
p <- arphitgg(long_data, aes = agg_aes(x = date, group = group_var), layout = "2h") + 
  agg_line(aes = agg_aes(y = y1), panel = "1") + 
  agg_col(aes = agg_aes(y = y2), panel = "3")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "inherit.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("inherit.png")
```

### Line layers

`agg_line` layers convert data and an aesthetic into line series in the chosen panel (or, panels if you set a facet variable in the aesthetic).

There are 7 options for line layers:

* The dataset to be drawn (`data`)
* The aesthetic that defines how to turn the data into a graph (`aes`)
* The colour (or colours) for the series (`color`)
* Point markers for the series (`pch`)
* The line type - e.g. solid or dashed - for the sereis (`lty`)
* The linewidth of the lines (`lwd`)
* The size of the point markers (`pointsize`). Only has any effect if `pch` is not NA.
* Which panel to plot the series on (`panel`). This is ignored if the aesthetic defines a facet variable.

### Column/bar layers

`agg_col` layers plot data as a vertical column graph. They have six options:

* The aesthetic that defines how to turn the data into a graph (`aes`)
* The dataset to be drawn (`data`)
* The colour (or colours) for the series (`color`)
* Point markers for the series (`barcol`)
* Which panel to plot the series on (`panel`). This is ignored if the aesthetic defines a facet variable.
* Whether the bars should be stacked (default) or grouped (`stacked`). This is a global option; you cannot combine stacked and grouped layers.

### Point/scatter layers

`agg_point` layers are just a wrapper around `agg_line` that set the line to NA, and the point marker (`pch`) to `19` for solid dots. Naturally, this layer type is best for scatter graphs, as they quicker and easier than constructing your own `agg_line` layer.

`agg_point` has only five arguments. Data (`data`), aesthetic (`aes`), panel (`panel`), colour for the markers (`color`) and a size for the points (`pointsize`). As with other layer types, data and aesthetic (including parts of an aesthetic) will be inherited from the parent if omitted.

# Series colours and other attributes

## Colours

Specifying line, bar or point (depending on layer type) colours for series is done when creating a layer. For instance:
```{r, results = "hide"}
p <- arphitgg() + 
  agg_line(data = simple_data, aes = agg_aes(x = date, y = y1), color = RBA["Red1"])
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "simplecolor.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("simplecolor.png")
```

This color is applied to _all_ series in the layer. This is less helpful when you have a group variable, since they will all show up as the same colour (which is unlikely to be what you want). E.g. this is not helpful:
```{r, results = "hide"}
p <- arphitgg() +
  agg_line(data = long_data,
           aes = agg_aes(x = date, y = y1, group = group_var),
           color = RBA["Red1"])
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "group-single-color.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("group-single-color.png")
```

To specify for different colours for different series in a grouped layer, you can instead specify a _vector_ of colours:
```{r, results = "hide"}
p <- arphitgg() +
  agg_line(data = long_data,
           aes = agg_aes(x = date, y = y1, group = group_var),
           color = c(RBA["Red1"], RBA["Blue4"]))
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "group-multi-color.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("group-multi-color.png")
```

(NB: `arphit` will cycle through the supplied vector colours if there aren't enough in the vector to cover the number of series in the layer.)

To see the full list of availble colours type `vignette("rba-colours", package = "arphit")`.

Alternatively, you can use any colour that R recognises.

If you don't specify colours, arphit cycles through a set of default colours. Should you need to (e.g. for labels) you can access the default colors using the alias `RBA["Default1"]` etc.

### (Advanced) Defining your own default colors

If you want to define your own set of default colors to be used set the option `arphit.user_colors` with a vector of colours. Putting this into your `.Rprofile` is sensible.
```{r, eval=FALSE}
options(arphit.user_colors = c(RBA["Red1"],RBA["Blue10"],RBA["Olive1"]))
```

## Line markers

`pch` allows you to add markers to your series. These directly follow the R options. These are specified like colours (setting one will apply it to all series in the layer, a vector will be cycled through).
```{r, results = "hide"}
p <- arphitgg(simple_data) + 
  agg_line(agg_aes(x = date, y = y1), pch = 19)
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "pch.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("pch.png")
```

## Line type

`lty` allows you to control the line type - e.g. add dashing. These directly follow the R options. These are specified like colours (setting one will apply it to all series in the layer, a vector will be cycled through).
```{r, results = "hide"}
p <- arphitgg(simple_data) + 
  agg_line(agg_aes(x = date, y = y1), lty = 2)
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "lty.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("lty.png")
```

## Line width

`lwd` controls the width of the line. 1 corresponds to default. 2 to twice default, 0.5 half it, etc. These are specified like colours (setting one will apply it to all series in the layer, a vector will be cycled through).
```{r, results = "hide"}
p <- arphitgg(simple_data) + 
  agg_line(agg_aes(x = date, y = y1), lwd = 3)
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "lwd.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("lwd.png")
```

## Bar outline

`barcol` lets you set the colour of the bar outline for `agg_col` layers. By default, this is `NA`, meaning no outline. These are specified like colours (setting one will apply it to all series in the layer, a vector will be cycled through).
```{r, results = "hide"}
p <- arphitgg(simple_data) + 
  agg_col(agg_aes(x = date, y = y1), barcol = "black")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "barcol.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("barcol.png")
```

## Point size

`pointsize` lets change the size of plot markers on `agg_line` or `agg_point` layers. By default, this is 1, meaning the default size. These are specified like colours (setting one will apply it to all series in the layer, a vector will be cycled through).
```{r, results = "hide"}
p <- arphitgg(data.frame(x=rnorm(15),y=rnorm(15))) + 
  agg_point(agg_aes(x = x, y = y), pointsize = 2) + 
  agg_point(agg_aes(x = x, y = y))
  
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "pointsize.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("pointsize.png")
```

# Titles and subtitles

Titles and subtitles are added using `agg_title` and `agg_subtitle` respectively. The only required argument is the text for the title/subtitle:
```{r results = "hide"}
p <- arphitgg() + 
  agg_title("Graph Title Goes Here") + 
  agg_subtitle("Or a subtitle, if you like")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "title.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("title.png")
```

`arphit` will automatically place linebreaks in long titles but may not be smart enough in all cases. You can insert linebreaks yourself as necessary by using "\\n".

```{r, results = "hide"}
p <- arphitgg() + 
  agg_title("Here is a very very very long title that arphit will automatically put a break in") +
  agg_subtitle("And a subtitle\nwith a manual break too")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "longtitle.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("longtitle.png")
```

# Panel titles and subtitles

You can add titles and subtitles to panels in much the same way as titles and subtitles. Allyou do is specify `panel` as an argument:
```{r, results = "hide"}
p <- arphitgg() + 
  agg_title("Panel title for panel 1", panel = "1") +
  agg_subtitle("And a subtitle", panel = "1")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "paneltitles.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("paneltitles.png")
```

# Units

You can specify the units for your graph using the `agg_units` function. This can be used either with or without a panel specifier. If called without a panel specifier, the units are applied to all panels, otherwise the units are added only to specified panel:
```{r results = "hide"}
p <- arphitgg() + agg_units("index")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "units-all.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("units-all.png")
```

```{r results = "hide"}
p <- arphitgg() +
  agg_units("index", panel = "1") +
  agg_units("ppt", panel = "2")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "units-specific.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("units-specific.png")
```

## x-axis units

You can also add units for the x-axis in much the same way. These are ignored for anything other than scatter graphs.
```{r, results = "hide"}
p <- arphitgg(scatter_data, agg_aes(x=x,y=y)) + 
  agg_point() + agg_xunits("ppt")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "x-units.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("x-units.png")
```

# Sources and footnotes

Adding sources and footnotes is done using `agg_source` and `agg_footnote`. You can pass in a single text string, or a vector of multiple strings. You can add as many `agg_source`/`agg_footnote` as you like:
```{r results = "hide"}
p <- arphitgg() + 
  agg_source("Source 1") + 
  agg_source(c("Source 2 (as a vector)", "Source 3 (vectors are easy!")) + 
  agg_footnote("This is my first footnoote") + 
  agg_footnote("This is a second footnote")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "sources.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("sources.png")
```

# Axis limits

## Y axis

`arphit` will automatically guess axes for each panel. However, it is not smart enough to sensibly line up axes across panels (e.g. if you have left and right axes). And stacked bar graphs will confuse it.

Y-limits can be controlled with `agg_ylim`. This function takes three required arguments: a minimum, a maximum, and the number of steps to include. You can optionally include a panel identifier; if omitted, the limits will be applied to all panels.

### Example 1: Manually setting left and right axes
```{r, results = "hide"}
p <- arphitgg(simple_data) + 
  agg_line(agg_aes(x=date,y=y1),panel="1") + 
  agg_line(agg_aes(x=date,y=y1),panel="2") + 
  agg_ylim(-1,1,5,panel="1") +
  agg_ylim(-4,4,5,panel="2")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "ylim-left-right-axes.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("ylim-left-right-axes.png")
```

### Example 2: Applying the same y axis to all panels
```{r, results = "hide"}
p <- arphitgg(simple_data) + 
  agg_line(agg_aes(x=date,y=y1),panel="1") + 
  agg_line(agg_aes(x=date,y=y1),panel="2") + 
  agg_ylim(-1,1,5)
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "ylim-all-axes.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("ylim-all-axes.png")
```

## X axis

X-limits are controlled using `agg_xlim`. This is similar to y-limits, but only a minimum and maximum is required. For time series graphs, you can use part years if desired by adding decimal places (e.g. `2000.5`).

As with the y-axis you can specify a panel identifier to apply the limits to a specific panel; if you omit the panel identifier, the limits will be applied to all panels.

Fine-grained control of x-ticks is not currently possible; only the limits can be set, the ticks are determined automatically. Time series graphs only support year ticks; higher frequency - such as months or quarters are not supported.
```{r, results = "hide"}
p <- arphitgg(simple_data, agg_aes(x=date, y=y1)) + 
  agg_line() + 
  agg_xlim(1998, 2008)
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "x-axis-lim.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("x-axis-lim.png")
```

You can specify only an upper or lower bound by setting the other the `NA`. For instance, to start the above graph at `2001` but let the data determine where to end it:
```{r, results = "hide"}
p <- arphitgg(simple_data, agg_aes(x=date, y=y1)) + 
  agg_line() + 
  agg_xlim(2001, NA)
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "x-axis-lim-single-arg.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("x-axis-lim-single-arg.png")
```

For layouts with vertical division (e.g. "2v", "2b2" etc), you can drop the the first tick of the right hand panel by setting `dropxlabel = TRUE` in `arphitgg`. This prevents the last label of the left hand panel overlapping the first of the right hand panel.
```{r, results = "hide"}
p <- arphitgg(simple_data, agg_aes(x=date, y=y1), layout = "2v", dropxlabel = TRUE) + 
  agg_line(panel = "1") +
  agg_line(panel = "2")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "drop-x-label.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("drop-x-label.png")
```

## Log axes

You can make either or both of the `y` and `x` axes log scales (`x` only makes sense for scatter graphs.) Use the `log_scale` option to `arphitgg` and specify one of `"x"`, `"y"` or `"xy"`, which behave as you'd expect.
```{r, results = "hide"}
log_scale_data <- data.frame(x = 1:10, y = c(11, 20, 40, 90, 11, 14, 90, 15, 15, 16))
p <- arphitgg(log_scale_data, agg_aes(x = x, y = y), log_scale = "y") + 
  agg_line() + 
  agg_ylim(10, 90, 5)
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "logscale.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("logscale.png")
```

# Shading between series

You can shade the area between series by adding `agg_shading`. 

Shading is drawn in the order you add it; the first shading added is on the bottom. Series are _always_ drawn on top of shading.
```{r, results = "hide"}
p <- arphitgg(simple_data, agg_aes(x=date)) +
  agg_line(agg_aes(y=y1)) +
  agg_line(agg_aes(y=y2)) +
  agg_shading(from = y1, to = y2, color = RBA["Blue1"])
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "shading-single.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("shading-single.png")
```

Multiple shading:
```{r, results = "hide"}
p <- arphitgg(simple_data, agg_aes(x=date)) +
  agg_line(agg_aes(y=y1)) +
  agg_line(agg_aes(y=y2)) +
  agg_line(agg_aes(y=y3)) +
  agg_line(agg_aes(y=y4)) +
  agg_shading(from = y1, to = y2, color = RBA["Blue1"]) + 
  agg_shading(from = y3, to = y4, color = "lightgrey")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "shading-multiple.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("shading-multiple.png")
```

# Plot annotations (labels, arrows and lines)

## Adding labels and arrows

You can add series labels, and arrows to aid those labels, using `agg_label` and `agg_arrow` arguments.

`agg_label` takes 5 arguments.

* `text` is the label text. You can add line breaks in text using the `\n` character.
* `x` and `y` specify where (in the units on the plot) the centre of the label should be. For time series, `x` is in decimal years (i.e. 2000.5 is July 2, 2000). For categorical graphs, 1 corresponds to the first categories, 2 to the second, etc.
* `panel` specifies which panel to place the label on.
* `color` is self-explanatory.
 
```{r, results = "hide"}
p <- arphitgg() +
  agg_label("A label", x = 2002, y = 0.5, color = RBA["Blue2"], panel = "1")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "labels.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("labels.png")
```

Arrows are specified with `agg_arrow`.

* `tail.x` and `tail.y` specify the coordinates (in the units on the plot) of where to start the arrow at.
* `head.x` and `head.y` where to finish the arrow (and where the arrow head is).
* `panel` specifies which panel to place the arrow on.
* `color` is self-explanatory.
* `lwd` is optional and specifies the linewidth of the arrow (default = 1).
 
```{r, results = "hide"}
p <- arphitgg() +
  agg_arrow(tail.x = 2000, tail.y = 0, head.x = 2001, head.y = 0.5, color = RBA["Blue1"], panel = "1")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "arrow.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("arrow.png")
```

## (Experimental) Automatic labels

`arphit` has (experimental) functionality to _automatically_ add series labels for you. If enabled, the auto labeller will run on panels with more than one series, and which do not already have text labels. If you manually set text labels for a panel, the auto labeller will skip that panel. It will also add arrows from the label to the series if necessary.

The autolabeller is still in early stages. Performance in particular is a problem, and it struggles to find locations for some graphs. Work is underway to improve it.

### Series names

The auto labeller will use whatever your series are called in the data. For long data, this will be the value of the group variable.

### Enabling the auto labeller

Enable the auto labeller by adding `agg_autolabel()`:
```{r, results = "hide"}
p <- arphitgg(long_data, agg_aes(x = date, y = y1, group = group_var)) +
  agg_line() + 
  agg_autolabel()
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "autolabel.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("autolabel.png")
```

If you put text labels on a panel, that disables the auto labeller for that panel:
```{r, results = "hide"}
p <- arphitgg(long_data, agg_aes(x = date, y = y1, group = group_var), layout = "2v") +
  agg_line(panel = "1") + 
  agg_line(panel = "2") + 
  agg_label("Manual\nlabel disables\nautolabels", x = 2001, y = 1.5, col = "black", panel = "2") + 
  agg_autolabel()
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "autolabel2.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("autolabel2.png")
```

The autolabeller should correctly handle left and right hand series:
```{r, results = "hide"}
p <- arphitgg(simple_data, agg_aes(x = date), layout = "1") +
  agg_line(agg_aes(y = y1), panel = "1") + 
  agg_line(agg_aes(y = y2), col = RBA["Orange5"], panel = "2") + 
  agg_autolabel()
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "autolabel_rhs.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("autolabel_rhs.png")
```

### Caveats for the auto labeller
* The auto labeller can be _slow_, particularly if you have a lot of series. Be patient while it runs.
* There are no guarantees the auto labeller will be able to find labels for all series, particularly if you have many series.
* The auto labeller is random; each run will put the labels in a different location.

## Adding horizonal and vertical lines

Horizontal and vertical lines are added using `agg_abline`. Horizontal lines are drawn by specifying the `y` variable _only; vertical the `x` variable only. You can also control the color and line type. These are optional and default to a solid black line. You must also tell `arphit` which panel to put the line on.

The following example draws a vertical line at 2001 using the default colour and solid line. It also draws a horizontal line at -1 colored darkred and dashed (`lty = 2`).
```{r, results = "hide"}
p <- arphitgg() + 
  agg_abline(x = 2001, panel = "1") + 
  agg_abline(y = -1, color = "darkred", lty = 2, panel = "1")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "lines.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("lines.png")
```

If you need more control over the line, you can specify the coordinates of the line segment instead of using `x` or `y`.  To do so use `x1`, `x2`, `y1` and `y2` instead of `x` and `y`. All other options are the same. For example:
```{r, results = "hide"}
p <- arphitgg() + 
  agg_abline(x1 = 2000, y1 = -10, x2 = 2002, y2 = 5, panel = "1")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "specificlines.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("specificlines.png")
```

Entering NA (or omitting the argument) for any of `x1`, `y1`, `x2`, or `y2` will set that coordinate to the axis limit (with `x1` and `y1` going to the left and bottom axes and `x2` and `y2` to the right and top).

## Adding background shading

Background shading can be added using `agg_bgshading`. This draws a rectangle with bottom left corner at `x1`, `y1` and top right corner at `x2`,`y2`. Passing NA for any of the four coordinates will set that coordinate to the axis limit - this is useful for creating shading that stretches across a whole panel. `color` and `panel` are self-explanatory (color is optional and defaults to light grey).

This example creates horizontal shading across the whole panel between -1 and 3 on the y axis.
```{r, results = "hide"}
p <- arphitgg() + 
  agg_bgshading(x1 = NA, y1 = -0.5, x2 = NA, y2 = 0.5, panel = "1")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "bgshading.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("bgshading.png")
```

And this two panel example repeats the above example for panel 1, but puts light green shading between two dates on the bottom panel.
```{r, results = "hide"}
p <- arphitgg(layout = "2h") + 
  agg_bgshading(x1 = NA, y1 = -0.5, x2 = NA, y2 = 0.5, panel = "1") + 
  agg_bgshading(x1 = 2000.5, y1 = NA, x2 = 2001.5, y2 = NA, panel = "3", color = "lightgreen")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "bgshading.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("bgshading.png")
```

## Adding axis labels

You can add y and x axis labels to plots using `agg_yaxislabel` and `agg_xaxislabel`. These take the text for the axis label, plus an optional panel identifier. If omitted, the label is applied to all panels.
```{r, results = "hide"}
p <- arphitgg(layout = "2b2") + 
  agg_yaxislabel("A y axis label") + 
  agg_xaxislabel("An x label")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "oneaxislabel.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("oneaxislabel.png")
```

```{r, results = "hide"}
p <- arphitgg(layout = "2b2") + 
  agg_yaxislabel("Foo", panel = "1") + 
  agg_yaxislabel("Bar", panel = "3") + 
  agg_xaxislabel("An x label", panel = "3") + 
  agg_xaxislabel("Another x label", panel = "4")
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "differentaxislabel.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("differentaxislabel.png")
```

## Rotating x ticks

You can rotate x ticks using the `srt` option in `arphitgg`. It represents the rotation (in degrees):
```{r, results = "hide"}
p <- arphitgg(simple_data, agg_aes(x=date,y=y1), srt = 45) + agg_line()
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename =  "xlabel-rotation.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("xlabel-rotation.png")
```

# Joining and missing values

The `joined` argument controls how your graph behaves with missing values. When `joined = TRUE` (which is the default) the series will ignore the missing value and connect to the next non-missing value. When `joined = FALSE` the series will break.

For instance, let's use this series, with the middle observation missing:
```{r}
joining_data <- ts(data.frame(y = c(1,2,NA,3,4)), start = 2000, frequency = 1)
```

With `joined = TRUE`, the series continues straight across the missing value for 2002.
```{r, results = "hide"}
p <- arphitgg(joining_data, agg_aes(y = y), joined = TRUE) +
  agg_line()
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "joined.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("joined.png")
```

But when we set `joined = FALSE`, the series does not connect over the missing observation:
```{r, results = "hide"}
p <- arphitgg(joining_data, agg_aes(y = y), joined = FALSE) +
  agg_line()
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "unjoined.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("unjoined.png")
```

# Adding a legend

You can add a legend to your graph by adding `agg_legend()`. This can also take one optional argument to specify how many columns to have with `ncol`; `arphit` will automatically guess if you leave it blank.
```{r, results = "hide"}
p <- arphitgg(long_data, agg_aes(x = date, y = y1, group = group_var)) +
  agg_line() +
  agg_legend()
```
```{r, echo = FALSE, results = "hide", warning = FALSE, message = FALSE}
agg_draw(p, filename = "legend.png")
```
```{r, out.width = "50%", echo = FALSE, fig.align="center"}
knitr::include_graphics("legend.png")
```

`arphit` will ignore duplicate series in multiple panels (i.e. it will only put in one legend entry).

# Saving to a file

To save your graph to a file instead of displaying it, use `agg_draw` with the optional filename command. `arphit` will determine what file to save as, based on the extension of your filename. `png`, `emf`, `svg` and `pdf` are supported.
```{r, results = "hide", eval = FALSE}
p <- arphitgg(simple_data, aes = agg_aes(x = date, y = y1)) +
  agg_line()
agg_draw(p, filename = "my-graph.png")
agg_draw(p, filename = "my-graph.emf")
agg_draw(p, filename = "my-graph.svg")
agg_draw(p, filename = "my-graph.pdf")
```

You can also use the newer `EMFplus` format by using extention `.emf+`. This will still write an `emf` file, but
it is encoded as the newer EMF+ format.
```{r, eval = FALSE}
agg_qplot(data, filename = "my_filename.emf+")
```

## A note about EMF files

EMF files are problematic:

* EMF+ files do not render in paint or windows photo viewer properly, but will import fine into Word or PowerPoint (and looks fine when exported to PDF from Word).
* EMF files  will _not_ render if exported from Word as PDF; EMF+ will.

Additionally, only EMF+ files support partial transparency; EMF files do not.
